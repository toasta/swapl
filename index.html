<html>
<head>
<script src="external/live.js"></script>
<script src="external/jquery-3.6.0.min.js"></script>

<style>
  .mcc {
    display: inline-block;
    width: 1em;
    text-align: center;
    font-size: 1.6em;
    font-family: monospace;
    position: absolute;
  }

  #res {
    width: 900px;
    margin: 0 auto;
    margin-top: 5em;
    position: relative;
    top: 5em;
    left: 1em;
  }
</style>
<body>

<div id="res">
</div>

<div id="pleft_c">
Punkte: 
  <div id="pleft"></div>
</div>

<script>



function dqs(s)
{
  q= document.querySelector(s)
  return(q)
}


function Sleep(milliseconds) {
 return new Promise(resolve => setTimeout(resolve, parseInt(milliseconds,10)));
}



function do_setup(word)
{
    // BEGIN SETUP
    lenu = word.length;
    display = dqs("#res")
    $(display).innerText = '';
      cc = []
    sorti = []
    for(let i = 0; i < lenu; i++)
    {
      sorti.push(i)
    }
    sorti = shuffle(sorti)
    for(let i = 0; i < lenu; i++)
    {
      t = $(`<div class="mcc" id="cc${i}">*</div>`);
      $(display).append(t)
      t= dqs("#cc" + i)
      v=i/lenu * 2* Math.PI
      t.style.left = (Math.cos(v)*5 + 5) + "em"
      t.style.top = Math.sin(v)*5 + "em"
      sorti.push(i)
    }
    // END SETUP
}

function do_change(word_a)
{
  for(let i = 0; i < word_a.length; i ++)
  {
    e = $("#cc" + i)
    v_old = $(e).text()
    v_new = word_a[i]
    // console.log(v_old, "vs", v_new);

    if(v_old != v_new)
    {
      $(e).fadeOut().html(v_new).fadeIn();
    }
  }
}

function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle...
  while (currentIndex != 0) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}


let rulenum = 0;
let curpos = []

// const run = async function() {
async function run(word) {
{
  word = word.toLowerCase();
  word_a = word.split("");
  do_setup(word_a);
    oword = word;
    mword = word;
    let lenu = word.length;

    orders = [];
    permu = 2 ;

    let co = 0;
    let co2 = 0

    let final_pos = []
    for(let i = 0; i < lenu; i++)
    {
      final_pos[i] = i;
      curpos[i] = i
    }

    while(co < permu && co2 < 1000)
    {
      co2 ++;
      let numbers = new Uint32Array(2);
      // while asking for more numbers at once
      // might be faster, we might not have
      // enough entropy?
      window.crypto.getRandomValues(numbers);
      v1 =  numbers[0] % lenu
      v2 =  numbers[1] % lenu

      if(v1 == v2) { continue; }

      // dont change same characters?
      if(final_pos[v1] == final_pos[v2]) { continue; }


      // this only catches "single run swaps", could still be endless
      if(co > 0)
      {
        if(1==0
          || (v1 == orders[co-1][0] && v2 == orders[co-1][1])
          || (v1 == orders[co-1][1] && v2 == orders[co-1][0])
        )
        {
          continue;
        }
      }

      console.log(final_pos);
      console.log("swap", v1, v2);
      final_pos[v1] = v2
      final_pos[v2] = v1
      console.log(final_pos);

      orders.push([v1, v2])
      co++;
    }
    if(co > 1000)
    {
      console.error("loop prevention")
      return;
    }
  console.log("final pos before show", final_pos);
  let s = document.createElement('style')
  s.type = 'text/css';
  tmp = []
    for(let i = 0; i < lenu; i++)
    {
      let left = (final_pos[i]*2) + "em"
      tmp.push(`
      @keyframes sp${i} {
        0% { }
        100% { top: 1em; left: ${left} }
      }
      `)
    }
  s.innerHTML = tmp.join("\n")
  document.head.appendChild(s)
    tim=1000
    for(let i = 0; i < lenu; i++)
    {
      e = dqs("#cc" + i)
      e.innerText = word_a[i]
      e.style.animation = `sp${i} ${tim}ms`
      e.style.animationFillMode = `forwards`;
    }

    await Sleep(tim+50);
    return;
    for(let i = permu-1; i >=0; i --)
    {
      $("#pleft").text(i);
      // effect one: fade out all and back but with orders applied
      // tbc
      // effect default: fade out and fade in one char
        // at a time
        // or out and after fading done queued
        const v1 = orders[i][0]
        const v2 = orders[i][1]
        //console.log("changin", v1, v2)

      //console.log("word pre", word_a);
      ani=2
      if(ani==2)
      {
        swap_move(v1,v2)
      } else
      {
        const t = word_a[v1]
        word_a[v1] = word_a[v2];
        word_a[v2] = t
        do_change(word_a)
      }




        await Sleep(1000);
    }
  }
}

async function swap_move(n1, n2)
{
  cp1 = curpos[n1]
  cp2 = curpos[n2]

  e1 = dqs("#cc" + n1);
  e2 = dqs("#cc" + n2);

  fp1 = (cp1 * 2) + "em";
  fp2 = (cp2 * 2) + "em";

  tp1 = (n2 * 2) + "em";
  tp2 = (n1 * 2) + "em";
  console.log("switching", n1, n2);

  name1 = `ttrans${rulenum}0`
  name2 = `ttrans${rulenum}1`
  let s = document.createElement('style')
  s.type = 'text/css';
  s.innerHTML = `
  @keyframes ${name1} {
    0% { top: 1em;    left: ${fp1};}
    50% { top: 0em; }
    100% { top: 1em;  left: ${tp2};}
  }
  @keyframes ${name2} {
    0% { top: 1em;    left: ${fp2}}
    50% { top: 2em; }
    100% { top: 1em;  left: ${tp1};}
  }
  `;
  document.head.appendChild(s)

  tim = 500

  e1.style.animation = `${name1} ${tim}ms ease-in-out 0s 1 normal forwards`
  e2.style.animation = `${name2} ${tim}ms ease-in-out 0s 1 normal forwards`
  
  rulenum++;
  await Sleep(tim+10);

  curpos[n1] = tp1
  curpos[n2] = tp2

  console.log("updating current positions", n1, tp1, n2, tp2);

}

$.ajax({url: 'dyn/wlist.json'}).done(function(d) {
  words = d
  let r = new Uint32Array(1);
  window.crypto.getRandomValues(r);
  v1 =  r[0] % words.length;
  run('1234');
  });


</script>
</body>
</html>
