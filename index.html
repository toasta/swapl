<html>
<head>
<script src="external/live.js"></script>
<script src="external/jquery-3.6.0.min.js"></script>

<style>
  .mcc {
    display: inline-block;
    width: 1em;
    text-align: center;
    font-size: 1.6em;
    font-family: monospace;
    position: absolute;
    /*
    background-color: black;
    color: white;
    padding: .33em;
    margin: .33em;
    */
  }

  #res {
    width: 900px;
    margin: 0 auto;
    margin-top: 5em;
    position: relative;
    top: 5em;
    left: 1em;
  }
</style>
<body>

<div id="res">
</div>

<div id="pleft_c">
Punkte: 
  <div id="pleft"></div>
</div>

<script>

TIME_ANI_SETUP = 3000
TIME_ANI_SWAP  = 1500


function dqs(s)
{
  q= document.querySelector(s)
  return(q)
}


function Sleep(milliseconds) {
 return new Promise(resolve => setTimeout(resolve, parseInt(milliseconds,10)));
}



function do_setup(word_a, elem_at_pos, anitime=5000)
{
    // BEGIN SETUP
    lenu = word_a.length;
    display = dqs("#res")
    $(display).innerText = '';

    // rotations
    xys = []
    for(let i = 0; i < 360; i++)
    {
      v=i* Math.PI/180;
      pl = (Math.cos(v))
      pt = (Math.sin(v))
      xys.push([pl, pt])
    }

    order = []
    for(let i = 0; i < lenu; i++)
    {
      order[i] = i;
    }

    order = shuffle(order)

  let s = document.createElement('style')
  s.type = 'text/css';
  tmp = []

    for(let j = 0; j < lenu; j++)
    {

      i = order[j]
      
      t = $(`<div class="mcc" id="cc${i}">${word_a[i]}</div>`);
      tmp2 = []
      tmp2.push(`@keyframes rpos${i} {`);
      offset = Math.floor(360/lenu * i)
      last = ['', '']
      for(let j = 0; j < 360; j+= 1)
      {

        percent = (j / 360)*100*.90
        tmp2.push(`${percent}% {
          transform: rotate(-${j}deg);
          top: ${xys[(j+offset)%360][0]*5 + 2.5}em;
          left: ${xys[(j+offset)%360][1]*5 + 8.5}em;
        }
        `);
      }
      pos2elem = []
      // elem to pos
      // pos -- idx in array
      // 0 1 2 3 4
      // 1 0 3 4 2
        for(let k = 0; k < lenu; k++)
        {
          pos2elem[ elem_at_pos[k] ] = k
          // ?!?
        }
        left = (2 * pos2elem[i]) + "em"

        tmp2.push(`100% {
          transform: rotate(0deg);
          left: ${left};
          top: 1em;
          //padding: .33em;
          //margin: .33em;
          //background-color: black;
          //color: white;
        }
        `);
        $(display).append(t)
        e=dqs("#cc" + i)
        e.style.top = '1em';
        set_pos_after_ani(e, left, '1em')
      tmp2.push(`}`);
      tmp.push(...tmp2)

    }
  s.innerHTML = tmp.join("\n")
  document.head.appendChild(s)
      for(let i = 0; i < lenu; i++)
       {
        dqs("#cc" + i).style.animation = `rpos${i} ${anitime/1000}s forwards`;
       }
    // END SETUP
}

function set_pos_after_ani(e, left, top)
{
  
        e.addEventListener('animationend', (ev) => {
          e=ev.target;
          e.style.left = left;
          e.style.top = top;
        });
}

function do_change(word_a)
{
  for(let i = 0; i < word_a.length; i ++)
  {
    e = $("#cc" + i)
    v_old = $(e).text()
    v_new = word_a[i]
    // console.log(v_old, "vs", v_new);

    if(v_old != v_new)
    {
      $(e).fadeOut().html(v_new).fadeIn();
    }
  }
}

function shuffle(array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle...
  while (currentIndex != 0) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}


let rulenum = 0;
    let elem_at_pos = []

// const run = async function() {
async function run(_word) {
{

    const word = _word.toLowerCase();
    let word_a = word.split("");
    let lenu = word.length;

    orders = [];
    permu = 8 ;

    let co = 0;
    let co2 = 0

    for(let i = 0; i < lenu; i++)
    {
      elem_at_pos[i] = i;
    }

    while(co < permu && co2 < 1000)
    {
      co2 ++;
      let numbers = new Uint32Array(2);
      // while asking for more numbers at once
      // might be faster, we might not have
      // enough entropy?
      window.crypto.getRandomValues(numbers);
      v1 =  numbers[0] % lenu
      v2 =  numbers[1] % lenu

      if(v1 == v2) { continue; }

      // dont change same characters?
      if(word_a[v1] == word_a[v2]) { continue; }


      // this only catches "single run swaps", could still be endless
      if(co > 0)
      {
        console.log(orders[co-1])
        if(1==0
          || (v1 == orders[co-1][0] && v2 == orders[co-1][1])
          || (v1 == orders[co-1][1] && v2 == orders[co-1][0])
        )
        {
          continue;
        }
      }

      // we swap elements
      // so we have to keep track which element is where
      const t1 = elem_at_pos[v1]
      const t2 = elem_at_pos[v2]
      elem_at_pos[v1] = t2;
      elem_at_pos[v2] = t1;

      orders.push([t1, v2, t2, v1 ])


      co++;
    }
    if(co2 >= 1000)
    {
      console.error("loop prevention")
      return;
    }

  tim=TIME_ANI_SETUP
  do_setup(word_a, elem_at_pos, tim);

  for(let i = 0; i < lenu; i++)
  {
  }
  await Sleep(tim+10);

    // traverse back
    for(let i = permu-1; i >=0; i --)
    {
      $("#pleft").text(i);

      const id1 = orders[i][0]
      const id2 = orders[i][2]
      
      const e1 = dqs("#cc" + id1)
      const e2 = dqs("#cc" + id2)
      const t1 = orders[i][1]
      const t2 = orders[i][3]

      ani=2
      if(ani==2)
      {
        tim=TIME_ANI_SWAP
        swap_move(e1, t1, e2, t2, i, tim)
        elem_at_pos[t1] = id1
        elem_at_pos[t2] = id2
        await Sleep(tim+50);
      } else
      {
        const t = word_a[v1]
        word_a[v1] = word_a[v2];
        word_a[v2] = t
        do_change(word_a)
      }



    }
  }
}

async function swap_move(e1, _t1, e2, _t2, idx, tim)
{
  t1 = (2*_t1)
  t2 = (2*_t2)

  let s = document.createElement('style')
  s.type = 'text/css';
  tmp = []
  endpos1 = t2 + "em";
  endpos2 = t1 + "em";
  tmp.push(`
      @keyframes transit${idx}0 {
        0% { }
        50% { top: 0em; }
        100% { top: 1em; left: ${endpos1}; }
      }
      `)
  tmp.push(`
      @keyframes transit${idx}1 {
        0% { }
        50% { top: 2em; }
        100% { top: 1em; left: ${endpos2}; }
      }
      `)
  s.innerHTML = tmp.join("\n")
  document.head.appendChild(s)

  e1.style.animation = `transit${idx}0 ${tim}ms forwards`
  e2.style.animation = `transit${idx}1 ${tim}ms forwards`
  set_pos_after_ani(e1, endpos1, '1em');
  set_pos_after_ani(e2, endpos2, '1em');

  /*
  for(let i = 0; i < lenu; i++)
  {
    e= dqs('#cc' + i)
    e.style.left = (2*i) + "em";
    e.style.animation = ''
  }
  */

}

$.ajax({url: 'dyn/wlist.json'}).done(function(d) {
  words = d
  let r = new Uint32Array(1);
  window.crypto.getRandomValues(r);
  v1 =  r[0] % words.length;
  run(words[v1])
  });


</script>
</body>
</html>
